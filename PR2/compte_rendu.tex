\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{breqn}
\usepackage{xcolor}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\definecolor{gray0}{RGB}{235,235,235}
\definecolor{gray1}{RGB}{220,220,220}
\definecolor{gray2}{RGB}{205,205,205}

\begin{document}

	\title{\textbf{Compte rendu Projet 2 - SE201}}
	\date{October 7, 2016}
	\maketitle

	\Large{\textbf{3 - Pipelining}}\\\break
    \small
    \underline{3.1}\\
    \setlength{\parindent}{5ex}\par
	En observant les instructions, on remarque un data hazard lors de l'execution de l'instruction 3.
	En effet, le store (instrution 3) nécessite la valeur du registre 29, mais celle-ci n'est pas encore à jour.
	L'instruction précédent qui écrit dans ce registre n'est pas encore terminée.\\
	Au cycle 17, la valeur de r29 n'est pas à jour mais elle devrait être chargée par le store qui est en ID.
	Au cycle 18, l'instruction 3 passe directement à l'execution sans avoir attentdu de pouvoir lire la valeur du registre 29.
	Il y a donc bien forwarding.
	((((((((((-------->  INCLUDE 1.PNG  <---------))))))))))))
	\\\break
    \underline{3.2}\\
    \par
	Première exemple : \\
	((((((((((-------->  INCLUDE 2.PNG  <---------))))))))))))
	Dans le cas d'un jump (jr) ou d'une condition (beqz, bnez) à cause une "misprediction" le processeur va "flush" les instructions qui avaient été commencé. 
	Celles-ci ne se finiront jamais.  
	Second exemple : \\
	((((((((((-------->  INCLUDE 3.PNG  <---------))))))))))))
	\\\break
\underline{3.3}\\
    \par


		  \\\break
		  \underline{4.1}\\
				\par
				1-bit saturation counting branch predictor : misprediction rate = 19.14%
				2-bit saturation counting branch predictor : misprediction rate = 18.09%

				Donc le branch predictor sur 2 bits est meilleur que celui sur 1bit. (Mais je ne sais pas comment justifier ...)

			\\\break
		  \underline{4.2}\\
				\par

				Selon les branches, on remarque quelques différences entre les branch predictors.
				Les branche où il y a une différences sont :

					 1-bit saturation counting branch predictor :
					 bpc: 0x00001104 [4] tgts: [0x0000113c] a:56 t/nt: 10/46 mp/cp: 9/47 mp-ratio: 0,16
					 bpc: 0x00001158 [88] tgts: [0x000010d4] a:27 t/nt: 21/6 mp/cp: 12/15 mp-ratio: 0,44

					 2-bit saturation counting branch predictor :
					 bpc: 0x00001104 [4] tgts: [0x0000113c] a:46 t/nt: 10/36 mp/cp: 10/36 mp-ratio: 0,22
					 bpc: 0x00001158 [88] tgts: [0x000010d4] a:27 t/nt: 21/6 mp/cp: 7/20 mp-ratio: 0,26

				Il n'y a pas de différence sur les autres branches.

				On remarque donc que pour la branche 0x00001104 [4] le branch predictor sur 1 bit est légèrement meilleur, mais sur la branche 0x00001158 [88], le branch predictor sur 2 bit est bien meilleur. 

		  \\\break
		  \underline{5.1}\\
				\par
				Nombre de ligne dans le cache : 4
				Taille d'un ligne dans le cache : 4
				Taille totale du cache : 16 octets
						  Accesses : 488
						  hits : 364
						  misses : 124
						  hit rate : 74,59%
						  loaded words : 124
		  \\\break
		  \underline{5.2}\\
				\par

				Nombre de ligne dans le cache : 8
				Taille d'un ligne dans le cache : 4
				Taille totale du cache : 32 octets
						  Accesses : 613
						  hits : 557
						  misses : 56
						  hit rate : 90,86%

				Nombre de ligne dans le cache : 16
				Taille d'un ligne dans le cache : 4
				Taille totale du cache : 64 octets
						  Accesses : 688
						  hits : 673
						  misses : 15
						  hit rate : 97,82%

				Nombre de ligne dans le cache : 32
				Taille d'un ligne dans le cache : 4
				Taille totale du cache : 128 octets
						  Accesses : 728
						  hits : 721
						  misses : 7
						  hit rate : 99,04%

				Nombre de ligne dans le cache : 64
				Taille d'un ligne dans le cache : 4
				Taille totale du cache : 256 octets
						  Accesses : 728
						  hits : 721
						  misses : 7
						  hit rate : 99,04%

				La taille du cache est égale à le taille d'une ligne multipliée par le nombre de ligne.
				Plus le nombre de ligne augmante, donc la taille du cache augmente, plus le hit rate augmente.
				Les configurations avec 32 lignes et 64 lignes offrent le meilleurs hit rate. Mais on peut dire que la meilleure configuration est celle avec 32 lignes car la taille du cache est plus petite que celle avec 64 lignes.


\end{document}
