\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{breqn}
\usepackage{xcolor}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\definecolor{gray0}{RGB}{235,235,235}
\definecolor{gray1}{RGB}{220,220,220}
\definecolor{gray2}{RGB}{205,205,205}

\begin{document}

	\title{\textbf{Compte rendu Projet 2 - SE201}}
	\date{October 7, 2016}
	\maketitle

	\Large{\textbf{3 - Pipelining}}\\\break
    \small
    \underline{3.1}\\
    \setlength{\parindent}{5ex}\par
	En observant les instructions, on remarque un data hazard lors de l'execution de l'instruction 3.
	En effet, le store (instrution 3) nécessite la valeur du registre 29, mais celle-ci n'est pas encore à jour.
	L'instruction précédent qui écrit dans ce registre n'est pas encore terminée.\\
	Au cycle 17, la valeur de r29 n'est pas à jour mais elle devrait être chargée par le store qui est en ID.
	Au cycle 18, l'instruction 3 passe directement à l'execution sans avoir attentdu de pouvoir lire la valeur du registre 29.
	Il y a donc bien forwarding.
	((((((((((-------->  INCLUDE 1.PNG  <---------))))))))))))
	\\\break
    \underline{3.2}\\
    \par
	Première exemple : \\
	((((((((((-------->  INCLUDE 2.PNG  <---------))))))))))))
	Dans le cas d'un jump (jr) ou d'une condition (beqz, bnez) à cause une "misprediction" le processeur va "flush" les instructions qui avaient été commencé. 
	Celles-ci ne se finiront jamais.  
	Second exemple : \\
	((((((((((-------->  INCLUDE 3.PNG  <---------))))))))))))
	\\\break
\underline{3.3}\\
    \par


		  \\\break
		  \underline{4.1}\\
				\par
				1-bit saturation counting branch predictor : misprediction rate = 19.14%
				2-bit saturation counting branch predictor : misprediction rate = 18.09%

				Donc le branch predictor sur 2 bits est meilleur que celui sur 1bit. (Mais je ne sais pas comment justifier ...)

			\\\break
		  \underline{4.2}\\
				\par

				Selon les branches, on remarque quelques différences entre les branch predictors.
				Les branche où il y a une différences sont :

					 1-bit saturation counting branch predictor :
					 bpc: 0x00001104 [4] tgts: [0x0000113c] a:56 t/nt: 10/46 mp/cp: 9/47 mp-ratio: 0,16
					 bpc: 0x00001158 [88] tgts: [0x000010d4] a:27 t/nt: 21/6 mp/cp: 12/15 mp-ratio: 0,44

					 2-bit saturation counting branch predictor :
					 bpc: 0x00001104 [4] tgts: [0x0000113c] a:46 t/nt: 10/36 mp/cp: 10/36 mp-ratio: 0,22
					 bpc: 0x00001158 [88] tgts: [0x000010d4] a:27 t/nt: 21/6 mp/cp: 7/20 mp-ratio: 0,26

				Il n'y a pas de différence sur les autres branches.

				On remarque donc que pour la branche 0x00001104 [4] le branch predictor sur 1 bit est légèrement meilleur, mais sur la branche 0x00001158 [88], le branch predictor sur 2 bit est bien meilleur. 


\end{document}
